<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>macOS内核拓展与用户态进程的通信实现（一）</title>
    <url>/2023/06/21/macOS%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>macOS内核拓展与用户态进程通信基本依靠<a class="link"   href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/NKEConceptual/control/control.html#//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_35" >KernControl <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> API及<a class="link"   href="https://developer.apple.com/documentation/kernel/iokit_fundamentals" >IOKit Fundamentals <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 框架。kern_control API对socket进行简单封装，用户态进程调用connect建立与内核的通信机制。IOKit则不仅提供用户态通信接口，实际上IOKit提供所有内核驱动的管控能力，包含驱动的注册、资源管理和调试等。</p>
<h2 id="KernControl内核编程"><a href="#KernControl内核编程" class="headerlink" title="KernControl内核编程"></a>KernControl内核编程</h2><p>内核拓展需调用ctl_register进行控制器的注册。函数原型为：<code> errno_t ctl_register(struct kern_ctl_reg *userkctl, kern_ctl_ref *kctlref);</code>。其中<code>userkctl</code>存放控制器相关配置，<code>kctlref</code>用于后续的消息发送和最后的控制器注销。消息传输调用<code>ctl_enqueuedata</code>实现，函数原型为<code>errno_t ctl_enqueuedata(kern_ctl_ref kctlref, u_int32_t unit, void *data, size_t len, u_int32_t flags);</code>。需要注意的是数据传输使用到的<code>unit</code>需在连接建立时获取，详见下面<code>kext_connect</code>函数实现。<br><code>kern_ctl_reg</code>结构体包含数据分发相关的函数指针，需自行实现。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Kext管控运行时环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ctl_reg</span> <span class="title">kctl_register</span>;</span>      <span class="comment">// kext注册器</span></span><br><span class="line">    kern_ctl_ref kctl_refrance;             <span class="comment">// kext注册引用</span></span><br><span class="line">    <span class="type">uint8_t</span> kext_unit;                      <span class="comment">// kext单元号</span></span><br><span class="line">    <span class="type">bool</span> is_connected;                      <span class="comment">// kext连接状态</span></span><br><span class="line">&#125; KextControlEnv;</span><br><span class="line">KextControlEnv g_kext_ctl;                      <span class="comment">// 内核拓展控制器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   kext控制器初始化</span></span><br><span class="line"><span class="comment"> * @return  错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">errno_t</span> <span class="title function_">kext_control_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">errno_t</span> error = KERN_SUCCESS;</span><br><span class="line">    bzero(&amp;g_kext_ctl, <span class="keyword">sizeof</span>(KextControlEnv));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化kext管控参数</span></span><br><span class="line">    strlcpy(g_kext_ctl.kctl_register.ctl_name, <span class="string">&quot;your kext name&quot;</span>, MAX_KCTL_NAME);</span><br><span class="line">    g_kext_ctl.kctl_register.ctl_flags = CTL_FLAG_PRIVILEGED;</span><br><span class="line">    g_kext_ctl.kctl_register.ctl_send = kext_send;</span><br><span class="line">    g_kext_ctl.kctl_register.ctl_getopt = sock_get_opt;</span><br><span class="line">    g_kext_ctl.kctl_register.ctl_setopt = sock_set_opt;</span><br><span class="line">    g_kext_ctl.kctl_register.ctl_connect = kext_connect;</span><br><span class="line">    g_kext_ctl.kctl_register.ctl_disconnect = kext_disconnect;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册kext控制器</span></span><br><span class="line">    error = ctl_register(&amp;g_kext_ctl.kctl_register, &amp;g_kext_ctl.kctl_refrance);</span><br><span class="line">    <span class="keyword">if</span> (error != KERN_SUCCESS) &#123;</span><br><span class="line">        LOG_C(LOG_ERROR, <span class="string">&quot;Failed to register kext controller with error code [%d].&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   kext控制器反初始化</span></span><br><span class="line"><span class="comment"> * @return  错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">errno_t</span> <span class="title function_">kext_control_uninit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">errno_t</span> error = KERN_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    error = ctl_deregister(g_kext_ctl.kctl_refrance);</span><br><span class="line">    <span class="keyword">if</span> (error != KERN_SUCCESS) &#123;</span><br><span class="line">        LOG_C(LOG_ERROR, <span class="string">&quot;Failed to deregister kext controller with error code [%d].&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           客户端设置配置回调</span></span><br><span class="line"><span class="comment"> * @param ctlref    kext控制引用</span></span><br><span class="line"><span class="comment"> * @param unit      kext单元号</span></span><br><span class="line"><span class="comment"> * @param command   操作标志</span></span><br><span class="line"><span class="comment"> * @return          错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">errno_t</span> <span class="title function_">sock_set_opt</span><span class="params">(kern_ctl_ref ctlref, <span class="type">unsigned</span> <span class="type">int</span> unit, <span class="type">void</span> *info, <span class="type">int</span> command, <span class="type">void</span> *data, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="type">errno_t</span> err_code = KERN_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (command) &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err_code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           客户端获取配置回调</span></span><br><span class="line"><span class="comment"> * @param ctlref    kext控制引用</span></span><br><span class="line"><span class="comment"> * @param unit      kext单元号</span></span><br><span class="line"><span class="comment"> * @param opt       操作标志</span></span><br><span class="line"><span class="comment"> * @return          错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">errno_t</span> <span class="title function_">sock_get_opt</span><span class="params">(kern_ctl_ref ctlref, <span class="type">unsigned</span> <span class="type">int</span> unit, <span class="type">void</span> *userdata, <span class="type">int</span> opt, <span class="type">void</span> *data, <span class="type">size_t</span> *len)</span> &#123;</span><br><span class="line">    <span class="comment">// 可不用实现</span></span><br><span class="line">    <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           客户端连接回调</span></span><br><span class="line"><span class="comment"> * @param ctlref    kext控制引用</span></span><br><span class="line"><span class="comment"> * @param sac       套接字地址控制器</span></span><br><span class="line"><span class="comment"> * @return          错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">errno_t</span> <span class="title function_">kext_connect</span><span class="params">(kern_ctl_ref ctlref, <span class="keyword">struct</span> sockaddr_ctl *sac, <span class="type">void</span> **unitinfo)</span> &#123;</span><br><span class="line">    <span class="type">errno_t</span> err_code = KERN_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (g_kext_ctl.is_connected == <span class="literal">true</span>) &#123;</span><br><span class="line">        LOG_C(LOG_ERROR, <span class="string">&quot;Failed to accept the connection request for a connection already established.&quot;</span>);</span><br><span class="line">        err_code = EISCONN;</span><br><span class="line">        <span class="keyword">return</span> err_code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_kext_ctl.is_connected = <span class="literal">true</span>;</span><br><span class="line">    g_kext_ctl.kext_unit = sac-&gt;sc_unit;</span><br><span class="line">    LOG_C(LOG_INFO, <span class="string">&quot;Connect with client successfully.&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> err_code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           客户端断开连接回调</span></span><br><span class="line"><span class="comment"> * @param ctlref    kext控制引用</span></span><br><span class="line"><span class="comment"> * @param unit      kext单元号</span></span><br><span class="line"><span class="comment"> * @return          错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">errno_t</span> <span class="title function_">kext_disconnect</span><span class="params">(kern_ctl_ref ctlref, <span class="type">unsigned</span> <span class="type">int</span> unit, <span class="type">void</span> *unitinfo)</span> &#123;</span><br><span class="line">    g_kext_ctl.is_connected = <span class="literal">false</span>;</span><br><span class="line">    LOG_C(LOG_INFO, <span class="string">&quot;Disconnect with peer successfully.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="KernControl用户态编程"><a href="#KernControl用户态编程" class="headerlink" title="KernControl用户态编程"></a>KernControl用户态编程</h2><p>用户态进程仅需调用<code>connect</code>函数发起连接，代码如下。OS X专门为内核通信定义了<code>PF_SYSTEM</code>域，该域支持<code>SYSPROTO_CONTROL</code>和<code>SYSPROTO_EVENT</code>两个协议。使用<code>SYSPROTO_CONTROL</code>协议的内核控制（kern_control）API允许应用程序配置和控制KEXT。使用<code>SYSPROTO_EVENT</code>协议的内核事件（kern_event）API允许在某些内核事件发生时通知应用程序和其他KEXT。一般来说，内核控制API是首选，因为它提供双向通信。</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  连接内核拓展</span></span><br><span class="line"><span class="comment"> * @return NO表示失败，否则成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)establishConnection &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.socketFD != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建kext管控套接字</span></span><br><span class="line">    _socketFD = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.socketFD == <span class="number">-1</span>) &#123;</span><br><span class="line">        LOG_OC(LOG_ERROR, <span class="string">&quot;Could not create socket.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化kext控制信息</span></span><br><span class="line">    <span class="keyword">struct</span> ctl_info info;</span><br><span class="line">    bzero(&amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    strlcpy(info.ctl_name, <span class="string">&quot;your kext name&quot;</span>, MAX_KCTL_NAME);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取动态设置的kext ID</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(<span class="keyword">self</span>.socketFD, <span class="built_in">CTLIOCGINFO</span>, &amp;info)) &#123;</span><br><span class="line">        LOG_OC(LOG_ERROR, <span class="string">&quot;Could not get ID for kernel control.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化套接字连接地址</span></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_ctl addr;</span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sc_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    addr.sc_family = AF_SYSTEM;</span><br><span class="line">    addr.ss_sysaddr = AF_SYS_CONTROL;</span><br><span class="line">    addr.sc_id = info.ctl_id;</span><br><span class="line">    addr.sc_unit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = connect(<span class="keyword">self</span>.socketFD, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        LOG_OC(LOG_ERROR, <span class="string">&quot;Connect failed with error code [%d].&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_OC(LOG_INFO, <span class="string">&quot;Connect with kext successfully.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 断开内核拓展连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)destroyConnection &#123;</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(<span class="keyword">self</span>.socketFD);</span><br><span class="line">    _socketFD = <span class="number">-1</span>;</span><br><span class="line">    LOG_OC(LOG_INFO, <span class="string">&quot;Disconnect with kext successfully.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>macOS开发</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>内核通信</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS内核拓展与用户态进程的通信实现（二）</title>
    <url>/2023/06/21/macOS%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p><a href="%5Bhttps://www.jianshu.com/p/4268e02e7c4c%5D(https://www.jianshu.com/p/4268e02e7c4c)">前面</a>已经讲解了基于KernControl API的通信实现，该实现相对简单，但有一些缺点。内核向应用层传输消息需调用<code>ctl_enqueuedata</code>接口，该接口实际将数据缓存至缓冲区，当需要瞬时大量传输消息时，缓冲区容量有限，将丢弃后来的数据。如果传输的数据有优先级，则需对<code>ctl_enqueuedata</code>接口进行二次封装，避免高优先级数据丢失。</p>
<p><a href="%5Bhttps://developer.apple.com/documentation/kernel/iokit_fundamentals%5D(https://developer.apple.com/documentation/kernel/iokit_fundamentals)">IOKit Fundamentals</a> 框架提供更加全面且方便的内核驱动API。<a href="%5Bhttps://developer.apple.com/documentation/kernel/ioservice-1g%5D(https://developer.apple.com/documentation/kernel/ioservice-1g)">IOService</a>是大多数内核驱动的基类，提供驱动实例化相关的各项服务。<a href="%5Bhttps://developer.apple.com/documentation/kernel/iouserclient%5D(https://developer.apple.com/documentation/kernel/iouserclient)">IOUserClient</a>是与用户态应用程序间通信的基类，通过继承并实现该类，可与客户端应用程序建立通信机制。<a href="%5Bhttps://developer.apple.com/documentation/kernel/ioshareddataqueue%5D(https://developer.apple.com/documentation/kernel/ioshareddataqueue)">IOSharedDataQueue</a>是非常便于使用的内核与用户态进程进行数据交换的通用队列，用户可自行设置队列大小。基于IOKit中的IOService、IOUserClient、IOSharedDataQueue可方便的实现内核与用户进程的通信和数据传输。下面结合代码进行简单实现，更多代码细节和工程配置可参考<a href="%5Bhttps://github.com/ConradSun/NuwaStone%5D(https://github.com/ConradSun/NuwaStone)">NuwaStone</a>项目。</p>
<h2 id="IOService内核编程"><a href="#IOService内核编程" class="headerlink" title="IOService内核编程"></a>IOService内核编程</h2><p>由于本次编写的为内核拓展，仅需要IOService进行驱动的加载与卸载管理，这里的代码实现很简单，仅需重写start、stop方法。如有加载卸载时的自定义操作可在函数中实现。</p>
<div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DriverService</span>.hpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DriverService</span> : <span class="title class_">public</span> <span class="title class_">IOService</span> &#123;</span><br><span class="line">    <span class="type">OSDeclareDefaultStructors</span>(<span class="type">DriverService</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Called by the kernel when the kext is loaded</span></span><br><span class="line">    bool start(<span class="type">IOService</span> <span class="operator">*</span>provider) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called by the kernel when the kext is unloaded</span></span><br><span class="line">    void stop(<span class="type">IOService</span> <span class="operator">*</span>provider) <span class="keyword">override</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    void clearInstances();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="IOUserClient内核编程"><a href="#IOUserClient内核编程" class="headerlink" title="IOUserClient内核编程"></a>IOUserClient内核编程</h2><p>编写继承于IOUserClient的类后需重写如下方法，相关源文件实现请参考开源项目。<code>registerNotificationPort</code>和<code>clientMemoryForType</code>用于数据交换队列的配置，<code>externalMethod</code>配置对外函数调用接口，对外接口的函数原型如<code>callYourMethod</code>定义。</p>
<div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DriverClient</span>.hpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DriverClient</span> : <span class="title class_">public</span> <span class="title class_">IOUserClient</span> &#123;</span><br><span class="line">    <span class="type">OSDeclareDefaultStructors</span>(<span class="type">DriverClient</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Called as part of IOServiceOpen in clients.</span></span><br><span class="line">    bool initWithTask(task_t owningTask, void <span class="operator">*</span>securityID, <span class="type">UInt32</span> type) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called after initWithTask as part of IOServiceOpen.</span></span><br><span class="line">    bool start(<span class="type">IOService</span> <span class="operator">*</span>provider) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when this class is stopping.</span></span><br><span class="line">    void stop(<span class="type">IOService</span> <span class="operator">*</span>provider) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when a client manually disconnects (via IOServiceClose).</span></span><br><span class="line">    <span class="type">IOReturn</span> clientClose(void) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when a client dies.</span></span><br><span class="line">    <span class="type">IOReturn</span> clientDied(void) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called during termination.</span></span><br><span class="line">    bool didTerminate(<span class="type">IOService</span> <span class="operator">*</span>provider, <span class="type">IOOptionBits</span> options, bool <span class="operator">*</span><span class="keyword">defer</span>) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called in clients with IOConnectSetNotificationPort. 用于数据传输</span></span><br><span class="line">    <span class="type">IOReturn</span> registerNotificationPort(mach_port_t port, <span class="type">UInt32</span> type, <span class="type">UInt32</span> refCon) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called in clients with IOConnectMapMemory. 用于数据传输</span></span><br><span class="line">    <span class="type">IOReturn</span> clientMemoryForType(<span class="type">UInt32</span> type, <span class="type">IOOptionBits</span> <span class="operator">*</span>options, <span class="type">IOMemoryDescriptor</span> <span class="operator">**</span>memory) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called in clients with IOConnectCallScalarMethod. 设置对外通信调用接口</span></span><br><span class="line">    <span class="type">IOReturn</span> externalMethod(<span class="type">UInt32</span> selector, <span class="type">IOExternalMethodArguments</span> <span class="operator">*</span>arguments, <span class="type">IOExternalMethodDispatch</span> <span class="operator">*</span>dispatch, <span class="type">OSObject</span> <span class="operator">*</span>target, void <span class="operator">*</span>reference) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义对外调用方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">IOReturn</span> callYourMethod(<span class="type">OSObject</span> <span class="operator">*</span>target, void <span class="operator">*</span>reference, <span class="type">IOExternalMethodArguments</span> <span class="operator">*</span>arguments);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="IOKit客户端编程"><a href="#IOKit客户端编程" class="headerlink" title="IOKit客户端编程"></a>IOKit客户端编程</h2><p>连接内核拓展前需先进行加载，加载调用<code>KextManagerLoadKextWithIdentifier</code>或<code>KextManagerLoadKextWithURL</code>即可。内核拓展需在plist中配置<code>IOService</code>及<code>IOUserClient</code>类名，在拓展启动后可通过类名进行查找匹配。首先需查找注册了指定类名的内核驱动，代码如下：</p>
<div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">startProvider</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> service <span class="operator">=</span> <span class="type">IOServiceMatching</span>(<span class="string">&quot;your service name&quot;</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Logger</span>(.<span class="type">Info</span>, <span class="string">&quot;Wait for kext to be connected.&quot;</span>)</span><br><span class="line">        waitForDriver(matchingDict: service)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>service存放匹配成功的驱动字典，然后需要创建通信端口和处理队列进行处理连接请求。处理连接请求时所持有的IOService对象需注意释放。调用IOServiceOpen接口即可建立连接，后面的IOConnectCallScalarMethod表示调用驱动对外接口进行连接测试。函数返回前需将用于连接请求处理的端口释放。通过IOConnectCallScalarMethod或IOConnectCallStructMethod可调用驱动对外接口，其中ScalarMethod仅可传输有限数量的常量，StructMethod则可传输自定义结构体类型，相关驱动配置可参照NuwaStone项目。</p>
<div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">processConnectionRequest</span>(<span class="params">iterator</span>: io_iterator_t) &#123;</span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            <span class="comment">// 持有的对象需进行释放</span></span><br><span class="line">            <span class="keyword">let</span> nextService <span class="operator">=</span> <span class="type">IOIteratorNext</span>(iterator)</span><br><span class="line">            <span class="keyword">guard</span> nextService <span class="operator">!=</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 建立与内核驱动的连接</span></span><br><span class="line">            <span class="keyword">var</span> result <span class="operator">=</span> <span class="type">IOServiceOpen</span>(nextService, mach_task_self_, <span class="number">0</span>, <span class="operator">&amp;</span>connection)</span><br><span class="line">            <span class="keyword">if</span> result <span class="operator">!=</span> kIOReturnSuccess &#123;</span><br><span class="line">                <span class="type">Logger</span>(.<span class="type">Error</span>, <span class="string">&quot;Failed to open kext service [<span class="subst">\(String.<span class="keyword">init</span>(format: <span class="string">&quot;0x%x&quot;</span>, result))</span>].&quot;</span>)</span><br><span class="line">                <span class="type">IOObjectRelease</span>(nextService)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用驱动方法测试连接</span></span><br><span class="line">            result <span class="operator">=</span> <span class="type">IOConnectCallScalarMethod</span>(connection, kNuwaUserClientOpen.rawValue, <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> result <span class="operator">!=</span> kIOReturnSuccess &#123;</span><br><span class="line">                <span class="type">Logger</span>(.<span class="type">Error</span>, <span class="string">&quot;An error occurred while opening the connection [<span class="subst">\(result)</span>].&quot;</span>)</span><br><span class="line">                <span class="type">IOObjectRelease</span>(nextService)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">IOObjectRelease</span>(nextService)</span><br><span class="line">            <span class="type">IONotificationPortDestroy</span>(notificationPort)</span><br><span class="line">            isConnected <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            <span class="type">Logger</span>(.<span class="type">Info</span>, <span class="string">&quot;Connected with kext successfully.&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">func</span> <span class="title function_">waitForDriver</span>(<span class="params">matchingDict</span>: <span class="type">CFDictionary</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> iterator: io_iterator_t <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> selfPointer <span class="operator">=</span> <span class="type">Unmanaged</span>.passUnretained(<span class="keyword">self</span>).toOpaque()</span><br><span class="line">        <span class="keyword">let</span> notificationQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;your queue name&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> appearedCallback: <span class="type">IOServiceMatchingCallback</span> <span class="operator">=</span> &#123; refcon, iterator <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> selfPtr <span class="operator">=</span> <span class="type">Unmanaged</span>&lt;<span class="type">YourClassName</span>&gt;.fromOpaque(refcon<span class="operator">!</span>).takeUnretainedValue()</span><br><span class="line">            selfPtr.processConnectionRequest(iterator: iterator)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        notificationPort <span class="operator">=</span> <span class="type">IONotificationPortCreate</span>(kIOMasterPortDefault)</span><br><span class="line">        <span class="type">IONotificationPortSetDispatchQueue</span>(notificationPort, notificationQueue)</span><br><span class="line">        <span class="type">IOServiceAddMatchingNotification</span>(notificationPort, kIOMatchedNotification, matchingDict, appearedCallback, selfPointer, <span class="operator">&amp;</span>iterator)</span><br><span class="line">        processConnectionRequest(iterator: iterator)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们通过调用<code>IOServiceOpen</code>存放<code>io_connect_t</code>类型的对象建立了与内核驱动的连接，相应的，断开连接时需调用<code>IOServiceClose</code>接口。</p>
<div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">stopProvider</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">IOServiceClose</span>(connection)</span><br><span class="line">        <span class="keyword">if</span> result <span class="operator">!=</span> <span class="type">KERN_SUCCESS</span> &#123;</span><br><span class="line">            <span class="type">Logger</span>(.<span class="type">Error</span>, <span class="string">&quot;Failed to close IOService [<span class="subst">\(String.<span class="keyword">init</span>(format: <span class="string">&quot;0x%x&quot;</span>, result))</span>].&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        connection <span class="operator">=</span> <span class="type">IO_OBJECT_NULL</span></span><br><span class="line">        isConnected <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>macOS开发</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>内核通信</tag>
        <tag>socket</tag>
      </tags>
  </entry>
</search>
